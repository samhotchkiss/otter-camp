package api

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/samhotchkiss/otter-camp/internal/store"
)

const (
	browserCommitTypeWriting = "writing"
	browserCommitTypeReview  = "review"
	browserCommitTypeSystem  = "system"

	defaultBrowserCommitMinBodyChars = 48
)

type projectCommitCreateRequest struct {
	Path          string  `json:"path"`
	Content       string  `json:"content"`
	CommitSubject *string `json:"commit_subject,omitempty"`
	CommitBody    *string `json:"commit_body,omitempty"`
	CommitType    *string `json:"commit_type,omitempty"`
	AuthorName    *string `json:"author_name,omitempty"`
	AuthorEmail   *string `json:"author_email,omitempty"`
}

type projectCommitCreateResponse struct {
	ProjectID            string               `json:"project_id"`
	Path                 string               `json:"path"`
	CommitType           string               `json:"commit_type"`
	AutoGeneratedMessage bool                 `json:"auto_generated_message"`
	Commit               projectCommitPayload `json:"commit"`
}

type browserCommitDiffSummary struct {
	Path       string
	ChangeType string
	Added      int
	Deleted    int
}

type browserCommitPolicy struct {
	Enabled      bool
	MinBodyChars int
}

type gitCommitSnapshot struct {
	AuthorName  string
	AuthorEmail *string
	AuthoredAt  time.Time
	Subject     string
	Body        *string
	Message     string
}

func (h *ProjectCommitsHandler) Create(w http.ResponseWriter, r *http.Request) {
	if h.ProjectStore == nil || h.CommitStore == nil || h.ProjectRepos == nil {
		sendJSON(w, http.StatusServiceUnavailable, errorResponse{Error: "database not available"})
		return
	}

	projectID := strings.TrimSpace(chi.URLParam(r, "id"))
	if projectID == "" {
		sendJSON(w, http.StatusBadRequest, errorResponse{Error: "project id is required"})
		return
	}
	if _, err := h.ProjectStore.GetByID(r.Context(), projectID); err != nil {
		handleProjectCommitStoreError(w, err)
		return
	}

	var req projectCommitCreateRequest
	decoder := json.NewDecoder(r.Body)
	decoder.DisallowUnknownFields()
	if err := decoder.Decode(&req); err != nil {
		sendJSON(w, http.StatusBadRequest, errorResponse{Error: "invalid JSON"})
		return
	}

	response, statusCode, err := h.createBrowserCommit(r.Context(), projectID, req)
	if err != nil {
		sendJSON(w, statusCode, errorResponse{Error: err.Error()})
		return
	}
	sendJSON(w, http.StatusCreated, response)
}

func (h *ProjectCommitsHandler) createBrowserCommit(
	ctx context.Context,
	projectID string,
	req projectCommitCreateRequest,
) (projectCommitCreateResponse, int, error) {
	if _, err := h.ProjectStore.GetByID(ctx, projectID); err != nil {
		return projectCommitCreateResponse{}, statusCodeForProjectCommitStoreError(err), err
	}

	normalizedPath, err := validateContentWritePath(req.Path)
	if err != nil {
		return projectCommitCreateResponse{}, http.StatusBadRequest, err
	}
	commitType := normalizeBrowserCommitType(req.CommitType)

	binding, err := h.ProjectRepos.GetBinding(ctx, projectID)
	if err != nil {
		return projectCommitCreateResponse{}, statusCodeForRepoStoreError(err), err
	}
	if !binding.Enabled {
		return projectCommitCreateResponse{}, http.StatusConflict, fmt.Errorf("github integration is disabled for this project")
	}
	if binding.LocalRepoPath == nil || strings.TrimSpace(*binding.LocalRepoPath) == "" {
		return projectCommitCreateResponse{}, http.StatusConflict, fmt.Errorf("project has no local repo path configured")
	}

	localRepoPath := strings.TrimSpace(*binding.LocalRepoPath)
	if err := ensureGitRepoPath(localRepoPath); err != nil {
		return projectCommitCreateResponse{}, http.StatusBadRequest, err
	}

	repoRelativePath := strings.TrimPrefix(normalizedPath, "/")
	absolutePath := filepath.Join(localRepoPath, filepath.FromSlash(repoRelativePath))
	if !isPathWithinRoot(localRepoPath, absolutePath) {
		return projectCommitCreateResponse{}, http.StatusBadRequest, fmt.Errorf("invalid content path")
	}

	if err := os.MkdirAll(filepath.Dir(absolutePath), 0o755); err != nil {
		return projectCommitCreateResponse{}, http.StatusInternalServerError, fmt.Errorf("failed to prepare parent directory")
	}
	if err := os.WriteFile(absolutePath, []byte(req.Content), 0o644); err != nil {
		return projectCommitCreateResponse{}, http.StatusInternalServerError, fmt.Errorf("failed to write content")
	}

	if _, err := runGitInRepo(ctx, localRepoPath, "add", "--", repoRelativePath); err != nil {
		return projectCommitCreateResponse{}, http.StatusBadRequest, err
	}

	hasChanges, err := gitHasCachedChangesForPath(ctx, localRepoPath, repoRelativePath)
	if err != nil {
		return projectCommitCreateResponse{}, http.StatusBadRequest, err
	}
	if !hasChanges {
		return projectCommitCreateResponse{}, http.StatusConflict, fmt.Errorf("no changes to commit")
	}

	summary, err := buildBrowserCommitDiffSummary(ctx, localRepoPath, normalizedPath, repoRelativePath)
	if err != nil {
		return projectCommitCreateResponse{}, http.StatusBadRequest, err
	}
	subject, body, autoGenerated := resolveBrowserCommitMessage(req, summary)
	if strings.TrimSpace(subject) == "" {
		return projectCommitCreateResponse{}, http.StatusBadRequest, fmt.Errorf("commit_subject is required")
	}
	policy := resolveBrowserCommitPolicyFromEnv()
	if err := validateBrowserCommitPolicy(commitType, body, policy); err != nil {
		return projectCommitCreateResponse{}, http.StatusUnprocessableEntity, err
	}

	authorName := optionalStringValue(req.AuthorName)
	if authorName == "" {
		authorName = "OtterCamp Browser"
	}
	authorEmail := optionalStringValue(req.AuthorEmail)
	if authorEmail == "" {
		authorEmail = "ottercamp-browser@localhost"
	}

	committed := false
	defer func() {
		if committed {
			return
		}
		_, _ = runGitInRepo(context.Background(), localRepoPath, "reset", "--", repoRelativePath)
	}()

	commitArgs := []string{
		"-c", "user.name=" + authorName,
		"-c", "user.email=" + authorEmail,
		"commit",
		"--only",
		"-m", subject,
	}
	if body != nil && strings.TrimSpace(*body) != "" {
		commitArgs = append(commitArgs, "-m", strings.TrimSpace(*body))
	}
	commitArgs = append(commitArgs, "--", repoRelativePath)
	if _, err := runGitInRepo(ctx, localRepoPath, commitArgs...); err != nil {
		return projectCommitCreateResponse{}, http.StatusBadRequest, err
	}
	committed = true

	sha, err := runGitInRepo(ctx, localRepoPath, "rev-parse", "HEAD")
	if err != nil {
		return projectCommitCreateResponse{}, http.StatusBadRequest, err
	}
	sha = strings.TrimSpace(sha)

	branchName := strings.TrimSpace(binding.DefaultBranch)
	if currentBranch, branchErr := currentGitBranchName(ctx, localRepoPath); branchErr == nil && currentBranch != "" {
		branchName = currentBranch
	}
	if branchName == "" || branchName == "HEAD" {
		branchName = "main"
	}

	snapshot, err := readGitCommitSnapshot(ctx, localRepoPath, sha)
	if err != nil {
		return projectCommitCreateResponse{}, http.StatusBadRequest, err
	}
	metadata, err := buildBrowserCommitMetadata(ctx, localRepoPath, sha, repoRelativePath, summary)
	if err != nil {
		return projectCommitCreateResponse{}, http.StatusBadRequest, err
	}

	commit, _, err := h.CommitStore.UpsertCommit(ctx, store.UpsertProjectCommitInput{
		ProjectID:          projectID,
		RepositoryFullName: binding.RepositoryFullName,
		BranchName:         branchName,
		SHA:                sha,
		AuthorName:         snapshot.AuthorName,
		AuthorEmail:        snapshot.AuthorEmail,
		AuthoredAt:         &snapshot.AuthoredAt,
		Subject:            snapshot.Subject,
		Body:               snapshot.Body,
		Message:            snapshot.Message,
		Metadata:           metadata,
	})
	if err != nil {
		return projectCommitCreateResponse{}, statusCodeForProjectCommitStoreError(err), err
	}

	return projectCommitCreateResponse{
		ProjectID:            projectID,
		Path:                 normalizedPath,
		CommitType:           commitType,
		AutoGeneratedMessage: autoGenerated,
		Commit:               toProjectCommitPayload(*commit),
	}, http.StatusCreated, nil
}

func statusCodeForProjectCommitStoreError(err error) int {
	switch {
	case errors.Is(err, store.ErrNoWorkspace):
		return http.StatusUnauthorized
	case errors.Is(err, store.ErrForbidden):
		return http.StatusForbidden
	case errors.Is(err, store.ErrNotFound):
		return http.StatusNotFound
	default:
		return http.StatusBadRequest
	}
}

func statusCodeForRepoStoreError(err error) int {
	switch {
	case errors.Is(err, store.ErrNoWorkspace):
		return http.StatusUnauthorized
	case errors.Is(err, store.ErrForbidden):
		return http.StatusForbidden
	case errors.Is(err, store.ErrNotFound):
		return http.StatusNotFound
	default:
		return http.StatusBadRequest
	}
}

func normalizeBrowserCommitType(raw *string) string {
	value := strings.ToLower(strings.TrimSpace(optionalStringValue(raw)))
	switch value {
	case browserCommitTypeReview:
		return browserCommitTypeReview
	case browserCommitTypeSystem:
		return browserCommitTypeSystem
	default:
		return browserCommitTypeWriting
	}
}

func resolveBrowserCommitMessage(
	req projectCommitCreateRequest,
	summary browserCommitDiffSummary,
) (string, *string, bool) {
	subject := strings.TrimSpace(optionalStringValue(req.CommitSubject))
	body := trimOptionalString(req.CommitBody)
	if subject != "" {
		return subject, body, false
	}
	autoSubject, autoBody := generateBrowserCommitMessage(summary)
	return autoSubject, autoBody, true
}

func generateBrowserCommitMessage(summary browserCommitDiffSummary) (string, *string) {
	changeType := strings.ToLower(strings.TrimSpace(summary.ChangeType))
	subjectPrefix := "Update"
	switch changeType {
	case "added":
		subjectPrefix = "Add"
	case "removed":
		subjectPrefix = "Remove"
	case "renamed":
		subjectPrefix = "Rename"
	}
	subject := fmt.Sprintf("%s %s", subjectPrefix, strings.TrimSpace(summary.Path))
	body := fmt.Sprintf(
		"Path: %s\nChange type: %s\nLine summary: +%d / -%d",
		strings.TrimSpace(summary.Path),
		changeTypeOrFallback(changeType),
		summary.Added,
		summary.Deleted,
	)
	return subject, &body
}

func changeTypeOrFallback(changeType string) string {
	changeType = strings.TrimSpace(changeType)
	if changeType == "" {
		return "modified"
	}
	return changeType
}

func gitHasCachedChangesForPath(ctx context.Context, repoPath, relativePath string) (bool, error) {
	command := exec.CommandContext(ctx, "git", "diff", "--cached", "--quiet", "--", relativePath)
	command.Dir = repoPath
	command.Env = append(os.Environ(), "GIT_TERMINAL_PROMPT=0")
	if err := command.Run(); err != nil {
		var exitErr *exec.ExitError
		if errors.As(err, &exitErr) && exitErr.ExitCode() == 1 {
			return true, nil
		}
		return false, fmt.Errorf("git diff --cached --quiet failed: %w", err)
	}
	return false, nil
}

func buildBrowserCommitDiffSummary(
	ctx context.Context,
	repoPath string,
	normalizedPath string,
	repoRelativePath string,
) (browserCommitDiffSummary, error) {
	changeType := "modified"
	nameStatusOutput, err := runGitInRepo(ctx, repoPath, "diff", "--cached", "--name-status", "--", repoRelativePath)
	if err != nil {
		return browserCommitDiffSummary{}, err
	}
	for _, line := range strings.Split(strings.TrimSpace(nameStatusOutput), "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		fields := strings.Fields(line)
		if len(fields) == 0 {
			continue
		}
		status := strings.TrimSpace(fields[0])
		if len(status) == 0 {
			continue
		}
		switch status[0] {
		case 'A':
			changeType = "added"
		case 'D':
			changeType = "removed"
		case 'R':
			changeType = "renamed"
		default:
			changeType = "modified"
		}
		break
	}

	added := 0
	deleted := 0
	numstatOutput, err := runGitInRepo(ctx, repoPath, "diff", "--cached", "--numstat", "--", repoRelativePath)
	if err != nil {
		return browserCommitDiffSummary{}, err
	}
	for _, line := range strings.Split(strings.TrimSpace(numstatOutput), "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		fields := strings.Fields(line)
		if len(fields) < 2 {
			continue
		}
		added += parseNumstatCount(fields[0])
		deleted += parseNumstatCount(fields[1])
	}

	return browserCommitDiffSummary{
		Path:       normalizedPath,
		ChangeType: changeType,
		Added:      added,
		Deleted:    deleted,
	}, nil
}

func parseNumstatCount(raw string) int {
	raw = strings.TrimSpace(raw)
	if raw == "" || raw == "-" {
		return 0
	}
	value, err := strconv.Atoi(raw)
	if err != nil || value < 0 {
		return 0
	}
	return value
}

func currentGitBranchName(ctx context.Context, repoPath string) (string, error) {
	branch, err := runGitInRepo(ctx, repoPath, "rev-parse", "--abbrev-ref", "HEAD")
	if err != nil {
		return "", err
	}
	branch = strings.TrimSpace(branch)
	if branch == "HEAD" {
		return "", nil
	}
	return branch, nil
}

func readGitCommitSnapshot(ctx context.Context, repoPath, sha string) (gitCommitSnapshot, error) {
	output, err := runGitInRepo(
		ctx,
		repoPath,
		"show",
		"-s",
		"--format=%an%n%ae%n%aI%n%s%n%b",
		sha,
	)
	if err != nil {
		return gitCommitSnapshot{}, err
	}

	lines := strings.Split(output, "\n")
	if len(lines) < 4 {
		return gitCommitSnapshot{}, fmt.Errorf("unable to read commit metadata for %s", sha)
	}
	authorName := strings.TrimSpace(lines[0])
	if authorName == "" {
		authorName = "OtterCamp Browser"
	}
	email := strings.TrimSpace(lines[1])
	var authorEmail *string
	if email != "" {
		authorEmail = &email
	}
	authoredAt, err := time.Parse(time.RFC3339, strings.TrimSpace(lines[2]))
	if err != nil {
		return gitCommitSnapshot{}, fmt.Errorf("parse commit authored_at: %w", err)
	}
	subject := strings.TrimSpace(lines[3])
	bodyText := strings.TrimSpace(strings.Join(lines[4:], "\n"))
	var body *string
	message := subject
	if bodyText != "" {
		body = &bodyText
		message = subject + "\n\n" + bodyText
	}

	return gitCommitSnapshot{
		AuthorName:  authorName,
		AuthorEmail: authorEmail,
		AuthoredAt:  authoredAt.UTC(),
		Subject:     subject,
		Body:        body,
		Message:     message,
	}, nil
}

func buildBrowserCommitMetadata(
	ctx context.Context,
	repoPath string,
	sha string,
	repoRelativePath string,
	summary browserCommitDiffSummary,
) (json.RawMessage, error) {
	nameStatusOutput, err := runGitInRepo(
		ctx,
		repoPath,
		"show",
		"--format=",
		"--name-status",
		"--find-renames",
		sha,
		"--",
		repoRelativePath,
	)
	if err != nil {
		return nil, err
	}

	type metadataFile struct {
		Path       string `json:"path"`
		ChangeType string `json:"change_type"`
	}

	files := make([]metadataFile, 0)
	added := make([]string, 0)
	modified := make([]string, 0)
	removed := make([]string, 0)
	for _, line := range strings.Split(strings.TrimSpace(nameStatusOutput), "\n") {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		parts := strings.Split(line, "\t")
		if len(parts) < 2 {
			continue
		}
		rawStatus := strings.TrimSpace(parts[0])
		if rawStatus == "" {
			continue
		}

		changeType := "modified"
		path := strings.TrimSpace(parts[len(parts)-1])
		switch rawStatus[0] {
		case 'A':
			changeType = "added"
			added = append(added, path)
		case 'D':
			changeType = "removed"
			removed = append(removed, path)
		case 'R':
			changeType = "renamed"
			modified = append(modified, path)
		default:
			changeType = "modified"
			modified = append(modified, path)
		}
		files = append(files, metadataFile{
			Path:       path,
			ChangeType: changeType,
		})
	}

	sort.Strings(added)
	sort.Strings(modified)
	sort.Strings(removed)

	payload, err := json.Marshal(map[string]any{
		"source":      "browser_commit_api",
		"path":        summary.Path,
		"change_type": summary.ChangeType,
		"line_summary": map[string]int{
			"added":   summary.Added,
			"deleted": summary.Deleted,
		},
		"added":    added,
		"modified": modified,
		"removed":  removed,
		"files":    files,
	})
	if err != nil {
		return nil, err
	}
	return payload, nil
}

func isPathWithinRoot(rootPath, candidate string) bool {
	rootPath = filepath.Clean(strings.TrimSpace(rootPath))
	candidate = filepath.Clean(strings.TrimSpace(candidate))
	if rootPath == "" || candidate == "" {
		return false
	}
	relative, err := filepath.Rel(rootPath, candidate)
	if err != nil {
		return false
	}
	if relative == "." {
		return true
	}
	return !strings.HasPrefix(relative, ".."+string(filepath.Separator)) && relative != ".."
}

func optionalStringValue(value *string) string {
	if value == nil {
		return ""
	}
	return strings.TrimSpace(*value)
}

func resolveBrowserCommitPolicyFromEnv() browserCommitPolicy {
	enabled := true
	if raw := strings.TrimSpace(os.Getenv("OTTER_WRITING_COMMIT_POLICY_ENABLED")); raw != "" {
		switch strings.ToLower(raw) {
		case "0", "false", "off", "no":
			enabled = false
		}
	}

	minBodyChars := defaultBrowserCommitMinBodyChars
	if raw := strings.TrimSpace(os.Getenv("OTTER_WRITING_COMMIT_BODY_MIN_CHARS")); raw != "" {
		if parsed, err := strconv.Atoi(raw); err == nil && parsed > 0 {
			minBodyChars = parsed
		}
	}

	return browserCommitPolicy{
		Enabled:      enabled,
		MinBodyChars: minBodyChars,
	}
}

func validateBrowserCommitPolicy(commitType string, body *string, policy browserCommitPolicy) error {
	if !policy.Enabled {
		return nil
	}
	if strings.TrimSpace(commitType) != browserCommitTypeWriting {
		return nil
	}

	trimmedBody := ""
	if body != nil {
		trimmedBody = strings.TrimSpace(*body)
	}
	if trimmedBody == "" {
		return fmt.Errorf("commit_body is required for writing commits; include rationale and review context")
	}

	if len([]rune(trimmedBody)) < policy.MinBodyChars {
		return fmt.Errorf(
			"commit_body must be at least %d characters for writing commits",
			policy.MinBodyChars,
		)
	}
	return nil
}
